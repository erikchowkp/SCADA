
<style>
  button:disabled {
    background: #ddd !important;
    color: #777 !important;
    border: 1px solid #aaa !important;
    cursor: not-allowed !important;
    opacity: 0.6;
  }
  .pump-container, .selector-container { cursor: pointer; }
</style>

<div id="systemMimic" class="system-mimic" style="position: relative; width: 100%; height: 100%;">

    <div style="position: absolute; left: 403px; top: 265px; text-align: center;">
        <div id="selector1" class="selector-container"></div>
    </div>
    <div style="position: absolute; left: 563px; top: 265px; text-align: center;">
        <div id="selector2" class="selector-container"></div>
    </div>
</div>

<script>
  const LOC = "NBT";
  const SYS = "TRA";

  const config = {
    pits: [],
    pumps: [],
    ai_textb: [],
    selectors: [{"id":"selector1","equipment":"SPP001","type":"mode"},{"id":"selector2","equipment":"SPP001","type":"remote"}]
  };

  window.SCADA = window.parent.SCADA;
  const Core = window.SCADA.Core;
  const Symbols = window.SCADA.Symbols;

  function registerInitialHighlights() {
    if (!Core.Highlight) return;
    const mapId = id => document.getElementById(id);
    
    config.pits.forEach((pitId, i) => {
      const el = mapId(`pit${i + 1}`);
      const lbl = mapId(`pit${i + 1}Label`);
      if (el && lbl) Core.Highlight.register(`${LOC}-${SYS}-${lbl.textContent}`, el);
    });
    
    config.pumps.forEach((pumpId, i) => {
        const el = mapId(`pump${i + 1}`);
        const lbl = mapId(`pump${i + 1}Label`);
        if (el && lbl) Core.Highlight.register(`${LOC}-${SYS}-${lbl.textContent}`, el);
    });

    config.ai_textb?.forEach((aiId, i) => {
      const el = mapId(`ai${i + 1}`);
      if (el) Core.Highlight.register(`${LOC}-${SYS}-${aiId}`, el);
    });
    
    config.selectors.forEach(sel => {
        const el = mapId(sel.id);
        if (el) Core.Highlight.register(`${LOC}-${SYS}-${sel.equipment}`, el);
    });
    
    Core.Highlight.equipIfPending();
  }

  function safeInit() {
    const checkExist = () => {
      if ((config.pumps.length && document.getElementById("pump1")) ||
          (config.pits.length && document.getElementById("pit1")) ||
          (config.ai_textb.length && document.getElementById("ai1")) ||
          (config.selectors.length > 0 && document.getElementById("selector1"))) { 
        initSymbols(); 
      } else { 
        setTimeout(checkExist, 50); 
      }
    };
    checkExist();
  }

  if (document.readyState === "complete") { safeInit(); } else { window.addEventListener("load", safeInit); }

  function refreshTRA(pumps, pits, aiSymbols, selectorSymbols, PanelMode, PanelRemote, data, alarms) {
    if (!data || !alarms) return;
    try {
      config.pits.forEach((pitId, i) => {
        if (pits[i]) {
          const cls = pits[i].getVisualClass(data, alarms, LOC);
          pits[i].update(cls.pct, cls.visualClass);
          pits[i].showOverride(cls.override);
        }
      });

      pumps.forEach(pump => {
        if (pump) {
          const cls = pump.getVisualClass(data, alarms, LOC);
          pump.update(cls.visualClass);
          pump.showOverride((cls.run?.mo_i) || (cls.trip?.mo_i));
        }
      });

      config.ai_textb?.forEach((aiId, i) => {
        if (aiSymbols[i]) {
          const cls = aiSymbols[i].getVisualClass(data, alarms, LOC);
          if (cls.value !== null) {
            aiSymbols[i].update(cls.value, cls.limits, cls.decimals, cls.flash);
            aiSymbols[i].showOverride(cls.override);
          }
        }
      });

      // Update selectors manually
      config.selectors.forEach((sel, i) => {
          if (selectorSymbols[i]) {
              const tagSuffix = sel.type === 'mode' ? 'Panel.Mode' : 'Panel.LocalRemote';
              // Selectors use exact tag "Panel.Mode" / "Panel.LocalRemote" in data, not prefixed with EquipID
              const tag = tagSuffix;
              
              const cls = selectorSymbols[i].getVisualClass(data, LOC, tag);
              if (cls.state) selectorSymbols[i].update(cls.state);
              selectorSymbols[i].showOverride(cls.override);
          }
      });

    } catch (err) {
      console.error("TRA mimic refresh failed:", err);
    }
  }

  function initSymbols() {
    const initTasks = [];

    config.pumps.forEach((pumpId, i) => {
      if (!pumpId) { initTasks.push(Promise.resolve(null)); return; }
      initTasks.push(Symbols.Pump.init(`pump${i + 1}`, {
        equipKey: `${LOC}-${SYS}-${pumpId}`,
        faceplate: Core.Naming.buildFullName({ loc: LOC, sys: SYS, equipType: "SUP", equipId: pumpId.slice(-3) }),
        loc: LOC,
        noAutoRefresh: true,
        doc: document
      }));
    });

    config.pits.forEach((pitId, i) => {
      if (!pitId) { initTasks.push(Promise.resolve(null)); return; }
      initTasks.push(Symbols.Pit.init(`pit${i + 1}`, {
        equipKey: `${LOC}-${SYS}-${pitId}`,
        faceplate: Core.Naming.buildFullName({ loc: LOC, sys: SYS, equipType: "SPT", equipId: pitId.slice(-3) }),
        loc: LOC,
        noAutoRefresh: true,
        doc: document
      }));
    });

    const aiSymbols = [];
    config.ai_textb?.forEach((aiId, i) => {
      if (!aiId) { initTasks.push(Promise.resolve(null)); return; }
      initTasks.push(
        Symbols.AI_TEXTB.init(`ai${i + 1}`, {
          loc: LOC, sys: SYS, equipId: aiId.slice(-3), equipType: "FLO", unit: "L/h",
          noAutoRefresh: true,
          doc: document
        }).then(api => {
          aiSymbols[i] = api;
          return api;
        })
      );
    });

    const selectorSymbols = [];
    // Selectors init
    const selectorPromises = [

        Symbols.Selector.init('selector1', {
          equipKey: `${LOC}-${SYS}-SPP001`,
          type: "mode",
          tag: "Panel.Mode",
          faceplate: Core.Naming.buildFullName({ loc: LOC, sys: SYS, equipType: "SPP", equipId: "SPP001".slice(-3) }),
          loc: LOC,
          doc: document
        }).then(api => {
          selectorSymbols[0] = api;
          return api;
        }),

        Symbols.Selector.init('selector2', {
          equipKey: `${LOC}-${SYS}-SPP001`,
          type: "remote",
          tag: "Panel.LocalRemote",
          faceplate: Core.Naming.buildFullName({ loc: LOC, sys: SYS, equipType: "SPP", equipId: "SPP001".slice(-3) }),
          loc: LOC,
          doc: document
        }).then(api => {
          selectorSymbols[1] = api;
          return api;
        })
    ];
    initTasks.push(...selectorPromises);

    Promise.all(initTasks).then(symbols => {
      const pumpSymbols = symbols.slice(0, config.pumps.length);
      const pitSymbols = symbols.slice(config.pumps.length, config.pumps.length + config.pits.length);
      const aiSyms = symbols.slice(config.pumps.length + config.pits.length, config.pumps.length + config.pits.length + config.ai_textb.length);
      const selSyms = symbols.slice(config.pumps.length + config.pits.length + config.ai_textb.length);
      
      const PanelMode = { getVisualClass: () => ({}), update: () => {}, showOverride: () => {} };
      const PanelRemote = { getVisualClass: () => ({}), update: () => {}, showOverride: () => {} };

      if (Core.Highlight) {
        registerInitialHighlights();
        Core.Highlight.equipIfPending();
      }

      const sm = SCADA?.Core?.SocketManager;
      if (sm) {
        const scope = `system:${LOC}`;
        console.log(`ðŸ“¡ ${LOC}_${SYS}: Direct WS subscription to ${scope}`);

        let cachedPoints = {};
        let cachedAlarms = [];

        const handleSystemUpdate = (msg) => {
          if (msg.alarms) {
            cachedAlarms = Array.isArray(msg.alarms) ? msg.alarms : Object.values(msg.alarms);
            if (msg.type === 'alarms' || msg.type === 'alarm') {
              const data = { points: Object.values(cachedPoints) };
              refreshTRA(pumpSymbols, pitSymbols, aiSyms, selSyms, PanelMode, PanelRemote, data, cachedAlarms);
              return;
            }
          }

          if (msg.type === 'snapshot' && msg.points) {
            cachedPoints = msg.points;
            const data = { points: Object.values(cachedPoints) };
            refreshTRA(pumpSymbols, pitSymbols, aiSyms, selSyms, PanelMode, PanelRemote, data, cachedAlarms);
          }
          else if (msg.type === 'update' && msg.diffs?.points) {
            if (msg.diffs.points.changed) Object.assign(cachedPoints, msg.diffs.points.changed);
            if (msg.diffs.points.removed) msg.diffs.points.removed.forEach(key => delete cachedPoints[key]);
            
            const data = { points: Object.values(cachedPoints) };
            refreshTRA(pumpSymbols, pitSymbols, aiSyms, selSyms, PanelMode, PanelRemote, data, cachedAlarms);
          }
        };

        sm.subscribe(scope, handleSystemUpdate);
        sm.subscribe('alarms', handleSystemUpdate);

        window.addEventListener('beforeunload', () => {
          try {
            sm.unsubscribe(scope, handleSystemUpdate);
            sm.unsubscribe('alarms', handleSystemUpdate);
          } catch (e) { }
        });
      }
    });

    console.log("âœ… Mimic loaded");
    if (window.parent) { window.parent.postMessage({ type: "mimicReady" }, "*"); }
  }
</script>
