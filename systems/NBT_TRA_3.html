<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>sss</title>
    <style>
        body { margin: 0; padding: 0; background: #ffffff; overflow: hidden; }
        .symbol-container { position: absolute; }
        /* Add symbol specific container styles if needed */
        .pump-container, .pit-container, .selector-container, .ai_textb-container { cursor: pointer; }
    </style>
</head>
<body>
    <div id="mimic-container" style="position:relative; width:100%; height:100%;">
        
    <div style="position: absolute; left: 235.36181640625px; top: 584.0000076293945px; text-align: center;" data-equipment="SPP001">
        <div id="SPP001" class="selector-container"></div>
    </div>

    <div style="position: absolute; left: 369.36181640625px; top: 582.0000076293945px; text-align: center;" data-equipment="SPP001">
        <div id="SPP001" class="selector-container"></div>
    </div>

    </div>

    <script>
        
  const LOC = "NBT";
  const SYS = "TRA";

  const config = {
    pits: [],
    pumps: [],
    ai_textb: [],
    selectors: [{"id":"SPP001","equipment":"SPP001","type":"mode"},{"id":"SPP001","equipment":"SPP001","type":"remote"}]
  };

  window.SCADA = window.parent.SCADA;
  const Core = window.SCADA.Core;
  const Symbols = window.SCADA.Symbols;

  function registerInitialHighlights() {
    if (!Core.Highlight) return;
    const mapId = id => document.getElementById(id);
    
    // Auto-generated highlight registration based on config
    // (Simplified for brevity, matching original pattern)
    
    
    
    if(mapId('SPP001')) Core.Highlight.register('NBT-TRA-undefined', mapId('SPP001'));
    if(mapId('SPP001')) Core.Highlight.register('NBT-TRA-undefined', mapId('SPP001'));
    
    Core.Highlight.equipIfPending();
  }

  function safeInit() {
    const checkExist = () => {
      // Check if first element of each type exists if configured
      const ready = 
        (!config.pumps.length || document.getElementById("undefined")) &&
        (!config.pits.length || document.getElementById("undefined")) &&
        (!config.ai_textb.length || document.getElementById("undefined")) &&
        (!config.selectors.length || document.getElementById("SPP001"));
        
      if (ready) { 
        initSymbols(); 
      } else { 
        setTimeout(checkExist, 50); 
      }
    };
    checkExist();
  }

  if (document.readyState === "complete") { safeInit(); } else { window.addEventListener("load", safeInit); }

  // Refresh Function (Generic)
  function refreshTRA(pumps, pits, aiSymbols, selectorSymbols, PanelMode, PanelRemote, data, alarms) {
    if (!data || !alarms) return;
    try {
      // Pits
      config.pits.forEach((pitId, i) => {
        if (pits[i]) {
          const cls = pits[i].getVisualClass(data, alarms, LOC);
          pits[i].update(cls.pct, cls.visualClass);
          pits[i].showOverride(cls.override);
        }
      });

      // Pumps
      pumps.forEach(pump => {
        if (pump) {
          const cls = pump.getVisualClass(data, alarms, LOC);
          pump.update(cls.visualClass);
          pump.showOverride((cls.run?.mo_i) || (cls.trip?.mo_i));
        }
      });

      // AI
      config.ai_textb?.forEach((aiId, i) => {
        if (aiSymbols[i]) {
          const cls = aiSymbols[i].getVisualClass(data, alarms, LOC);
          if (cls.value !== null) {
            aiSymbols[i].update(cls.value, cls.limits, cls.decimals, cls.flash);
            aiSymbols[i].showOverride(cls.override);
          }
        }
      });

      // Selectors
      config.selectors.forEach((sel, i) => {
          if (selectorSymbols[i]) {
              const tagSuffix = sel.type === 'mode' ? 'Panel.Mode' : 'Panel.LocalRemote';
              const cls = selectorSymbols[i].getVisualClass(data, LOC, tagSuffix);
              if (cls.state) selectorSymbols[i].update(cls.state);
              selectorSymbols[i].showOverride(cls.override);
          }
      });

    } catch (err) {
      console.error("TRA mimic refresh failed:", err);
    }
  }

  function initSymbols() {
    const initTasks = [];

    // Pumps
    

    // Pits
    

    // AI
    const aiSymbols = [];
    

    // Selectors
    const selectorSymbols = [];
    
    initTasks.push(
        Symbols.Selector.init('SPP001', {
          equipKey: 'NBT-TRA-SPP001',
          type: "mode", // "mode" or "remote"
          tag: "Panel.Mode",
          faceplate: Core.Naming.buildFullName({ loc: LOC, sys: SYS, equipType: "SPP", equipId: "001" }),
          loc: LOC,
          doc: document
        }).then(api => { selectorSymbols[0] = api; return api; })
    );
    initTasks.push(
        Symbols.Selector.init('SPP001', {
          equipKey: 'NBT-TRA-SPP001',
          type: "remote", // "mode" or "remote"
          tag: "Panel.LocalRemote",
          faceplate: Core.Naming.buildFullName({ loc: LOC, sys: SYS, equipType: "SPP", equipId: "001" }),
          loc: LOC,
          doc: document
        }).then(api => { selectorSymbols[1] = api; return api; })
    );

    Promise.all(initTasks).then(symbols => {
      // Slice symbols back to arrays
      let offset = 0;
      const pumpSymbols = symbols.slice(offset, offset + 0); offset += 0;
      const pitSymbols = symbols.slice(offset, offset + 0); offset += 0;
      const aiSyms = symbols.slice(offset, offset + 0); offset += 0;
      const selSyms = symbols.slice(offset, offset + 2);

      const PanelMode = { getVisualClass: () => ({}), update: () => {}, showOverride: () => {} };
      const PanelRemote = { getVisualClass: () => ({}), update: () => {}, showOverride: () => {} };

      if (Core.Highlight) {
        registerInitialHighlights();
        Core.Highlight.equipIfPending();
      }

      const sm = SCADA?.Core?.SocketManager;
      if (sm) {
        const scope = `system:${LOC}`;
        console.log(`ðŸ“¡ ${LOC}_${SYS}: Direct WS subscription to ${scope}`);

        let cachedPoints = {};
        let cachedAlarms = [];

        const handleSystemUpdate = (msg) => {
          if (msg.alarms) {
            cachedAlarms = Array.isArray(msg.alarms) ? msg.alarms : Object.values(msg.alarms);
            if (msg.type === 'alarms' || msg.type === 'alarm') {
              const data = { points: Object.values(cachedPoints) };
              refreshTRA(pumpSymbols, pitSymbols, aiSyms, selSyms, PanelMode, PanelRemote, data, cachedAlarms);
              return;
            }
          }

          if (msg.type === 'snapshot' && msg.points) {
            cachedPoints = msg.points;
            const data = { points: Object.values(cachedPoints) };
            refreshTRA(pumpSymbols, pitSymbols, aiSyms, selSyms, PanelMode, PanelRemote, data, cachedAlarms);
          }
          else if (msg.type === 'update' && msg.diffs?.points) {
            if (msg.diffs.points.changed) Object.assign(cachedPoints, msg.diffs.points.changed);
            if (msg.diffs.points.removed) msg.diffs.points.removed.forEach(key => delete cachedPoints[key]);
            
            const data = { points: Object.values(cachedPoints) };
            refreshTRA(pumpSymbols, pitSymbols, aiSyms, selSyms, PanelMode, PanelRemote, data, cachedAlarms);
          }
        };

        sm.subscribe(scope, handleSystemUpdate);
        sm.subscribe('alarms', handleSystemUpdate);

        window.addEventListener('beforeunload', () => {
          try {
            sm.unsubscribe(scope, handleSystemUpdate);
            sm.unsubscribe('alarms', handleSystemUpdate);
          } catch (e) { }
        });
      }
    });

    console.log("âœ… Mimic loaded");
    if (window.parent) { window.parent.postMessage({ type: "mimicReady" }, "*"); }
  }

    </script>
</body>
</html>