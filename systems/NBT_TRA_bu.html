<style>
  button:disabled {
    background: #ddd !important;
    color: #777 !important;
    border: 1px solid #aaa !important;
    cursor: not-allowed !important;
    opacity: 0.6;
  }

  .pump-container,
  .selector-container {
    cursor: pointer;
  }
</style>

<div id="systemMimic" class="system-mimic" style="margin:20px;"></div>

<script>
  const LOC = "NBT";
  const SYS = "TRA";

  const config = {
    pits: ["SPT001"],
    pumps: ["SUP001", "SUP002", "SUP003"],
    panel: "SPP001",
    ai_textb: ["FLO001"]
  };

  window.SCADA = window.parent.SCADA;
  const Core = window.SCADA.Core;
  const Symbols = window.SCADA.Symbols;

  function buildLayout() {
    const container = document.getElementById("systemMimic");
    container.innerHTML = "";

    // --- Pits row ---
    const pitRow = document.createElement("div");
    pitRow.style.display = "flex";
    pitRow.style.alignItems = "flex-start";
    pitRow.style.gap = "40px";

    config.pits.forEach((pitId, i) => {
      const wrap = document.createElement("div");
      wrap.style.textAlign = "center";
      const pitDiv = document.createElement("div");
      pitDiv.id = `pit${i + 1}`;
      pitDiv.className = "pit-container";
      pitDiv.style.position = "relative";
      const label = document.createElement("div");
      label.id = `pit${i + 1}Label`;
      label.style.cssText = "font-size:12px; margin-top:4px;";
      label.textContent = pitId;
      wrap.append(pitDiv, label);
      pitRow.appendChild(wrap);
    });

    // --- Pumps column ---
    const pumpCol = document.createElement("div");
    pumpCol.style.display = "flex";
    pumpCol.style.flexDirection = "column";
    pumpCol.style.gap = "30px";
    pumpCol.style.marginTop = "10px";

    config.pumps.forEach((pumpId, i) => {
      const wrap = document.createElement("div");
      wrap.style.textAlign = "center";
      const pumpDiv = document.createElement("div");
      pumpDiv.id = `pump${i + 1}`;
      pumpDiv.className = "pump-container";
      const label = document.createElement("div");
      label.id = `pump${i + 1}Label`;
      label.style.cssText = "font-size:12px; margin-top:4px;";
      label.textContent = pumpId;
      wrap.append(pumpDiv, label);
      pumpCol.appendChild(wrap);
    });

    pitRow.appendChild(pumpCol);
    container.appendChild(pitRow);

    // --- Control Panel row ---
    const panelRow = document.createElement("div");
    Object.assign(panelRow.style, { display: "flex", gap: "30px", marginTop: "30px", alignItems: "center" });
    const panelMode = document.createElement("div"); panelMode.id = "panelMode"; panelMode.className = "selector-container";
    const panelRemote = document.createElement("div"); panelRemote.id = "panelRemote"; panelRemote.className = "selector-container";
    const panelLabel = document.createElement("div"); panelLabel.id = "panelLabel"; panelLabel.style.fontWeight = "bold"; panelLabel.textContent = config.panel;
    panelRow.append(panelMode, panelRemote, panelLabel);
    container.appendChild(panelRow);

    // --- Analogue text boxes row ---
    if (config.ai_textb?.length) {
      const aiRow = document.createElement("div");
      Object.assign(aiRow.style, { display: "flex", gap: "30px", marginTop: "30px" });
      config.ai_textb.forEach((aiId, i) => {
        const wrap = document.createElement("div"); wrap.style.textAlign = "center";
        const aiDiv = document.createElement("div"); aiDiv.id = `ai${i + 1}`; aiDiv.className = "ai_textb-container";
        const label = document.createElement("div"); label.id = `ai${i + 1}Label`; label.style.cssText = "font-size:12px; margin-top:0px;"; label.textContent = aiId;
        wrap.append(aiDiv, label);
        aiRow.appendChild(wrap);
      });
      container.appendChild(aiRow);
    }
  }

  function registerInitialHighlights() {
    if (!Core.Highlight) return;
    const mapId = id => document.getElementById(id);
    config.pits.forEach((pitId, i) => {
      const el = mapId(`pit${i + 1}`);
      const lbl = mapId(`pit${i + 1}Label`);
      if (el && lbl) Core.Highlight.register(`${LOC}-${SYS}-${lbl.textContent}`, el);
    });
    config.ai_textb.forEach((aiId, i) => {
      const el = mapId(`ai${i + 1}`);
      if (el) Core.Highlight.register(`${LOC}-${SYS}-${aiId}`, el);
    });
    ["panelMode", "panelRemote"].forEach(id => {
      const el = mapId(id);
      const text = document.getElementById("panelLabel")?.textContent || "";
      if (el) Core.Highlight.register(`${LOC}-${SYS}-${text}`, el);
    });
    Core.Highlight.equipIfPending();
  }

  buildLayout();

  function safeInit() {
    const checkExist = () => {
      if (document.getElementById("pump1")) { initSymbols(); } else { setTimeout(checkExist, 50); }
    };
    checkExist();
  }

  if (document.readyState === "complete") { safeInit(); } else { window.addEventListener("load", safeInit); }

  /* ======================================================
     REFRESH FUNCTION
  ====================================================== */
  function refreshTRA(pumps, pits, aiSymbols, PanelMode, PanelRemote, data, alarms) {
    if (!data || !alarms) return;
    try {
      // --- Pit updates (visuals and labels) ---
      config.pits.forEach((pitId, i) => {
        const pitPoint = data.points.find(p => p.tag === "Pit.HighLevel" && p.loc === LOC);
        const labelEl = document.getElementById(`pit${i + 1}Label`);
        if (labelEl && pitPoint) labelEl.textContent = pitPoint.label;

        // Update pit visuals (when noAutoRefresh is enabled)
        if (pits[i]) {
          const cls = pits[i].getVisualClass(data, alarms, LOC);
          pits[i].update(cls.pct, cls.visualClass);
          pits[i].showOverride(cls.override);
        }
      });

      // --- Pump labels ---
      config.pumps.forEach((pumpId, i) => {
        const runTag = `${pumpId}.RunFb`;
        const startTag = `${pumpId}.StartCmd`;
        const pumpPoint = data.points.find(p => p.tag === runTag && p.loc === LOC)
          || data.points.find(p => p.tag === startTag && p.loc === LOC);
        const labelEl = document.getElementById(`pump${i + 1}Label`);
        if (labelEl && pumpPoint) labelEl.textContent = pumpPoint.label;
      });

      // --- Pumps update ---
      pumps.forEach(pump => {
        const cls = pump.getVisualClass(data, alarms, LOC);
        pump.update(cls.visualClass);
        pump.showOverride((cls.run?.mo_i) || (cls.trip?.mo_i));
      });

      // --- Selector update (now using getVisualClass like pumps/pits) ---
      const modeCls = PanelMode.getVisualClass(data, LOC, "Panel.Mode");
      const remoteCls = PanelRemote.getVisualClass(data, LOC, "Panel.LocalRemote");

      if (modeCls.state) PanelMode.update(modeCls.state);
      if (remoteCls.state) PanelRemote.update(remoteCls.state);
      PanelMode.showOverride(modeCls.override);
      PanelRemote.showOverride(remoteCls.override);

      // --- AI_TEXTB updates ---
      config.ai_textb?.forEach((aiId, i) => {
        if (aiSymbols[i]) {
          const cls = aiSymbols[i].getVisualClass(data, alarms, LOC);
          if (cls.value !== null) {
            aiSymbols[i].update(cls.value, cls.limits, cls.decimals, cls.flash);
            aiSymbols[i].showOverride(cls.override);
          }
        }
      });

    } catch (err) {
      console.error("TRA mimic refresh failed:", err);
    }
  }

  function initSymbols() {
    const initTasks = [];

    // Pumps (Driven by page/refreshTRA)
    config.pumps.forEach((pumpId, i) => {
      initTasks.push(Symbols.Pump.init(`pump${i + 1}`, {
        equipKey: `${LOC}-${SYS}-${pumpId}`,
        faceplate: Core.Naming.buildFullName({ loc: LOC, sys: SYS, equipType: "SUP", equipId: pumpId.slice(-3) }),
        loc: LOC,
        noAutoRefresh: true,
        doc: document
      }));
    });

    // Pits (Now driven by page/refreshTRA like pumps)
    config.pits.forEach((pitId, i) => {
      initTasks.push(Symbols.Pit.init(`pit${i + 1}`, {
        equipKey: `${LOC}-${SYS}-${pitId}`,
        faceplate: Core.Naming.buildFullName({ loc: LOC, sys: SYS, equipType: "SPT", equipId: pitId.slice(-3) }),
        loc: LOC,
        noAutoRefresh: true,
        doc: document
      }));
    });

    // AI text boxes (Now driven by page/refreshTRA like other symbols)
    const aiSymbols = [];
    config.ai_textb?.forEach((aiId, i) => {
      initTasks.push(
        Symbols.AI_TEXTB.init(`ai${i + 1}`, {
          loc: LOC, sys: SYS, equipId: aiId.slice(-3), equipType: "FLO", unit: "L/h",
          noAutoRefresh: true,
          doc: document
        }).then(api => {
          aiSymbols[i] = api;
          return api;
        })
      );
    });

    // Panel selectors
    initTasks.push(Symbols.Selector.init("panelMode", {
      equipKey: `${LOC}-${SYS}-${config.panel}`,
      faceplate: Core.Naming.buildFullName({ loc: LOC, sys: SYS, equipType: "SPP", equipId: config.panel.slice(-3) }),
      loc: LOC, type: "mode", doc: document
    }));
    initTasks.push(Symbols.Selector.init("panelRemote", {
      equipKey: `${LOC}-${SYS}-${config.panel}`,
      faceplate: Core.Naming.buildFullName({ loc: LOC, sys: SYS, equipType: "SPP", equipId: config.panel.slice(-3) }),
      loc: LOC, doc: document
    }));

    Promise.all(initTasks).then(symbols => {
      const pumpSymbols = symbols.slice(0, config.pumps.length);
      const pitSymbols = symbols.slice(config.pumps.length, config.pumps.length + config.pits.length);
      const [PanelMode, PanelRemote] = symbols.slice(-2);

      // Expose to global scope for WebSocket callbacks
      // window.pumpSymbols = pumpSymbols;
      // window.pitSymbols = pitSymbols;
      // window.aiSymbols = aiSymbols;
      // window.PanelMode = PanelMode;
      // window.PanelRemote = PanelRemote;
      // window.refreshTRA = refreshTRA;

      if (Core.Highlight) {
        registerInitialHighlights();
        Core.Highlight.equipIfPending();
      }

      // === DIRECT WebSocket Subscription (Pure WebSocket Mode) ===
      const sm = SCADA?.Core?.SocketManager;
      if (sm) {
        const scope = `system:${LOC}`;
        console.log(`üì° NBT_TRA: Direct WS subscription to ${scope}`);

        // State cache for merging incremental updates
        let cachedPoints = {};
        let cachedAlarms = [];

        const handleSystemUpdate = (msg) => {

          // 1. Handle ALARMS (standalone or embedded)
          // SocketManager enriches msg with .alarms if missing, so we check that first
          if (msg.alarms) {
            // üö® CRITICAL FIX: SocketManager might provide an Object (map), but symbols expect an Array
            cachedAlarms = Array.isArray(msg.alarms) ? msg.alarms : Object.values(msg.alarms);

            // If it's purely an alarm message, we should refresh to show alarm state changes
            if (msg.type === 'alarms' || msg.type === 'alarm') {
              const data = { points: Object.values(cachedPoints) };
              refreshTRA(pumpSymbols, pitSymbols, aiSymbols, PanelMode, PanelRemote, data, cachedAlarms);
              return;
            }
          }

          // 2. Handle SNAPSHOT (full state)
          if (msg.type === 'snapshot' && msg.points) {
            cachedPoints = msg.points;
            // cachedAlarms already handled above if present
            const data = { points: Object.values(cachedPoints) };
            refreshTRA(pumpSymbols, pitSymbols, aiSymbols, PanelMode, PanelRemote, data, cachedAlarms);
          }

          // 3. Handle UPDATE (incremental)
          else if (msg.type === 'update' && msg.diffs?.points) {
            const changed = msg.diffs.points.changed || {};
            const removed = msg.diffs.points.removed || [];
            const count = Object.keys(changed).length + removed.length;

            if (count > 0) {
              if (msg.diffs.points.changed) {
                Object.assign(cachedPoints, msg.diffs.points.changed);
              }
              if (msg.diffs.points.removed) {
                msg.diffs.points.removed.forEach(key => delete cachedPoints[key]);
              }

              const data = { points: Object.values(cachedPoints) };
              refreshTRA(pumpSymbols, pitSymbols, aiSymbols, PanelMode, PanelRemote, data, cachedAlarms);
            }
          }
        };

        sm.subscribe(scope, handleSystemUpdate);
        sm.subscribe('alarms', handleSystemUpdate);

        // Cleanup on unload
        window.addEventListener('beforeunload', () => {
          try {
            sm.unsubscribe(scope, handleSystemUpdate);
            sm.unsubscribe('alarms', handleSystemUpdate);
          } catch (e) { }
        });
      } else {
        console.warn("‚ö†Ô∏è NBT_TRA: SocketManager not available");
      }

    });

    console.log("‚úÖ NBT_TRA mimic loaded (Phase 5)");
    if (window.parent) { window.parent.postMessage({ type: "mimicReady" }, "*"); }
  }
</script>