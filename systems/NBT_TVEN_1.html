<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>TVEN schem</title>
    <style>
        body { margin: 0; padding: 0; background-color: #fff; overflow: hidden; font-family: 'Segoe UI', sans-serif; user-select: none; }
        /* Zoom Container - White Background, No Scrollbars */
        #zoom-container { position: relative; width: 100vw; height: 100vh; overflow: hidden; display: flex; justify-content: center; align-items: center; background: #fff; cursor: default; }
        
        /* Dragging State */
        .dragging { cursor: grabbing !important; }
        
        /* Mimic Wrapper */
        #mimic-wrapper { 
            position: absolute; 
            top: 0;
            left: 0;
            width: 1200px; 
            height: 800px; 
            background-color: #fff;
            box-shadow: none;
            transform-origin: 0 0; 
            transition: none; 
        }
        
        
        .pump-container, .pit-container, .selector-container, .ai-container {
            width: 40px; height: 40px; /* Default size for placement */
            /* Actual SVG size matches these */
        }
        
        /* Zoom Controls */
        #zoom-controls {
            position: fixed; bottom: 20px; right: 20px; z-index: 9999;
            display: flex; flex-direction: column; gap: 5px;
        }
        .zoom-btn {
            width: 36px; height: 36px; background: #444; color: #fff; border: 1px solid #666; 
            border-radius: 4px; cursor: pointer; font-size: 18px; display: flex; align-items: center; justify-content: center;
        }
        .zoom-btn:hover { background: #666; }
    </style>
</head>
<body>

<div id="zoom-container">
    <div id="mimic-wrapper">
        <!-- Elements -->

    <div style="position: absolute; left: 253px; top: 130px; text-align: center;" data-equipment="TFAN001" data-location="NBT" data-system="TVEN">
        <div id="sym_1" class="tfan-container"></div>
    </div>

    </div> <!-- End Mimic Wrapper -->
</div> <!-- End Zoom Container -->

<div id="zoom-controls">
    <button class="zoom-btn" onclick="zoomIn()" title="Zoom In">+</button>
    <button class="zoom-btn" onclick="zoomReset()" title="Reset">1:1</button>
    <button class="zoom-btn" onclick="zoomOut()" title="Zoom Out">-</button>
</div>

<script>

  const LOC = "NBT";
  const SYS = "TVEN";

  const config = {
    pits: [],
    pumps: [],
    ai_textb: [],
    tfans: [{"id":"sym_1","equipment":"TFAN001","loc":"NBT","sys":"TVEN"}],
    selectors: []
  };

  window.SCADA = window.parent.SCADA;
  const Core = window.SCADA.Core;
  const Symbols = window.SCADA.Symbols;

  function registerInitialHighlights() {
    if (!Core.Highlight) return;
    const mapId = id => document.getElementById(id);
    
    // Auto-generated highlight registration based on config
    
    
    
    if(mapId('sym_1')) Core.Highlight.register('NBT-TVEN-TFAN001', mapId('sym_1'));
    
    
    Core.Highlight.equipIfPending();
  }

  function safeInit() {
    const checkExist = () => {
      // Check if first element of each type exists if configured
      const ready = 
        (!config.pumps.length || document.getElementById("undefined")) &&
        (!config.pits.length || document.getElementById("undefined")) &&
        (!config.ai_textb.length || document.getElementById("undefined")) &&
        (!config.tfans.length || document.getElementById("sym_1")) &&
        (!config.selectors.length || document.getElementById("undefined"));
        
      if (ready) { 
        initSymbols(); 
      } else { 
        setTimeout(checkExist, 50); 
      }
    };
    checkExist();
  }

  if (document.readyState === "complete") { safeInit(); } else { window.addEventListener("load", safeInit); }

  // Refresh Function (Generic)
  function refreshTVEN(pumps, pits, aiSymbols, tfanSymbols, selectorSymbols, PanelMode, PanelRemote, data, alarms) {
    if (!data || !alarms) return;
    try {
      // Pits
      config.pits.forEach((pConf, i) => {
        if (pits[i]) {
          const symLoc = pConf.loc || LOC;
          const cls = pits[i].getVisualClass(data, alarms, symLoc);
          pits[i].update(cls.pct, cls.visualClass);
          pits[i].showOverride(cls.override);
        }
      });

      // Pumps
      config.pumps.forEach((pConf, i) => {
        if (pumps[i]) {
          const symLoc = pConf.loc || LOC;
          const cls = pumps[i].getVisualClass(data, alarms, symLoc);
          pumps[i].update(cls.visualClass);
          pumps[i].showOverride((cls.run?.mo_i) || (cls.trip?.mo_i));
        }
      });

      // AI
      config.ai_textb?.forEach((pConf, i) => {
        if (aiSymbols[i]) {
          const symLoc = pConf.loc || LOC;
          const cls = aiSymbols[i].getVisualClass(data, alarms, symLoc);
          if (cls.value !== null) {
            aiSymbols[i].update(cls.value, cls.limits, cls.decimals, cls.flash);
            aiSymbols[i].showOverride(cls.override);
          }
        }
      });
      
      // TFans
      config.tfans?.forEach((pConf, i) => {
        if (tfanSymbols[i]) {
          const symLoc = pConf.loc || LOC;
          const cls = tfanSymbols[i].getVisualClass(data, alarms, symLoc);
          tfanSymbols[i].update(cls.visualClass);
          tfanSymbols[i].showOverride((cls.run?.mo_i) || (cls.trip?.mo_i) || (cls.mode?.mo_i) || (cls.dir?.mo_i));
        }
      });
      
      // Selectors
       config.selectors?.forEach((sConf, i) => {
         // Placeholder for future selector updates
       });

    } catch (e) { console.error("Refresh error:", e); }
  }



  function initSymbols() {
    const initTasks = [];

    // Pumps
    

    // Pits
    

    // AI
    const aiSymbols = [];
    

    // TFans
    const tfanSymbols = [];
    
    initTasks.push(
        Symbols.TFan.init('sym_1', {
          equipKey: 'NBT-TVEN-TFAN001',
          faceplate: Core.Naming.buildFullName({ loc: "NBT", sys: "TVEN", equipType: "TFAN", equipId: "001" }),
          loc: "NBT",
          noAutoRefresh: true,
          doc: document
        }).then(api => { tfanSymbols[0] = api; return api; })
    );

    // Selectors
    const selectorSymbols = [];
    

    Promise.all(initTasks).then(symbols => {
      // Slice symbols back to arrays
      let offset = 0;
      const pumpSymbols = symbols.slice(offset, offset + 0); offset += 0;
      const pitSymbols = symbols.slice(offset, offset + 0); offset += 0;
      const aiSyms = symbols.slice(offset, offset + 0); offset += 0;
      const tfanSyms = symbols.slice(offset, offset + 1); offset += 1;
      const selSyms = symbols.slice(offset, offset + 0);

      const PanelMode = { getVisualClass: () => ({}), update: () => {}, showOverride: () => {} };
      const PanelRemote = { getVisualClass: () => ({}), update: () => {}, showOverride: () => {} };

      if (Core.Highlight) {
        registerInitialHighlights();
        Core.Highlight.equipIfPending();
      }

      const sm = SCADA?.Core?.SocketManager;
      if (sm) {
        // Subscribe to all locations used
        sm.subscribe('system:NBT', handleSystemUpdate);
        
        sm.subscribe('alarms', handleSystemUpdate); 

        let cachedPoints = {};
        let cachedAlarms = [];

        function handleSystemUpdate(msg) {
          console.log("RX MSG:", msg.type, msg.points ? Object.keys(msg.points).length : 0);
          if (msg.alarms) {
            cachedAlarms = Array.isArray(msg.alarms) ? msg.alarms : Object.values(msg.alarms);
            
            if (msg.type === 'alarms' || msg.type === 'alarm') {
              const data = { points: Object.values(cachedPoints) };
              refreshTVEN(pumpSymbols, pitSymbols, aiSyms, tfanSyms, selSyms, PanelMode, PanelRemote, data, cachedAlarms);
              return;
            }
          }

          if (msg.type === 'snapshot' && msg.points) {
            // MERGE snapshot data
            Object.assign(cachedPoints, msg.points);
            console.log("Merged Snapshot. Total Points:", Object.keys(cachedPoints).length);
            const data = { points: Object.values(cachedPoints) };
            refreshTVEN(pumpSymbols, pitSymbols, aiSyms, tfanSyms, selSyms, PanelMode, PanelRemote, data, cachedAlarms);
          }
          else if (msg.type === 'update' && msg.diffs?.points) {
            if (msg.diffs.points.changed) Object.assign(cachedPoints, msg.diffs.points.changed);
            if (msg.diffs.points.removed) msg.diffs.points.removed.forEach(key => delete cachedPoints[key]);
            
            const data = { points: Object.values(cachedPoints) };
            refreshTVEN(pumpSymbols, pitSymbols, aiSyms, tfanSyms, selSyms, PanelMode, PanelRemote, data, cachedAlarms);
          }
        };

        window.addEventListener('beforeunload', () => {
          try {
             sm.unsubscribe('system:NBT', handleSystemUpdate);
            sm.unsubscribe('alarms', handleSystemUpdate);
            sm.unsubscribe('events', handleSystemUpdate);
          } catch (e) { }
        });
      }
    });
  } // End initSymbols

    // --- Zoom & Pan Logic ---
    const wrapper = document.getElementById('mimic-wrapper');
    const container = document.getElementById('zoom-container');
    
    // State
    let scale = 1;
    let panX = 0;
    let panY = 0;
    
    // Center initial view
    function centerView() {
        if (!container || !wrapper) return;
        const cw = container.clientWidth;
        const ch = container.clientHeight;
        const ww = 1200;
        const wh = 800;
        
        // Center alignment
        panX = (cw - ww * scale) / 2;
        panY = (ch - wh * scale) / 2;
        updateTransform();
    }
    
    // Set initial center
    window.onload = function() {
       // Wait for layout to settle?
       centerView();
    };

    function updateTransform() {
        if (wrapper) wrapper.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    }

    // Button Controls
    window.zoomIn = function() {
        // Zoom towards center of screen
        const cx = container.clientWidth / 2;
        const cy = container.clientHeight / 2;
        zoomToPoint(1.2, cx, cy);
    };
    
    window.zoomOut = function() {
        const cx = container.clientWidth / 2;
        const cy = container.clientHeight / 2;
        zoomToPoint(1/1.2, cx, cy);
    };
    
    window.zoomReset = function() {
        scale = 1;
        centerView();
    };
    
    function zoomToPoint(factor, cx, cy) {
        const newScale = scale * factor;
        // Limit zoom
        if (newScale < 0.1 || newScale > 10) return;
        
        // Math to zoom towards point (cx, cy)
        // (cx - panX) / scale = worldX
        // newPanX = cx - worldX * newScale
        const worldX = (cx - panX) / scale;
        const worldY = (cy - panY) / scale;
        
        panX = cx - worldX * newScale;
        panY = cy - worldY * newScale;
        scale = newScale;
        updateTransform();
    }
    
    // Mouse Wheel Zoom (Smooth)
    if (container) {
        container.addEventListener('wheel', (e) => {
            e.preventDefault();
            const factor = e.deltaY < 0 ? 1.05 : 0.95;
            zoomToPoint(factor, e.clientX, e.clientY);
        }, { passive: false });
        
        // Panning (Middle Mouse or Left Mouse on Container background)
        let isDragging = false;
        let lastX = 0;
        let lastY = 0;
        
        container.addEventListener('mousedown', (e) => {
            // Allow middle click (1) or left click (0) if not on an interactive element?
            // User specifically asked for "holding the mouse wheel" (Middle Click).
            if (e.button === 1) { 
                isDragging = true;
                container.classList.add('dragging');
                lastX = e.clientX;
                lastY = e.clientY;
                e.preventDefault(); // Prevent scroll icon
            }
        });
        
        window.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = e.clientX - lastX;
                const dy = e.clientY - lastY;
                panX += dx;
                panY += dy;
                lastX = e.clientX;
                lastY = e.clientY;
                updateTransform();
            }
        });
        
        window.addEventListener('mouseup', () => {
            isDragging = false;
            container.classList.remove('dragging');
        });
    }
    
</script>
</body>
</html>