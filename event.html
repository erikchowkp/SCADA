<script src="js/mimicMap.js"></script>

<div id="eventPage">
  <div id="eventListContainer">
    <div id="eventList">
      <table id="eventTable">
        <thead>
          <tr>
            <th>Time</th>
            <th>Loc</th>
            <th>Sys</th>
            <th>Label</th>
            <th>Description</th>
            <th>State</th>
            <th>Type</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>
  <div id="eventFilter">
    
    <div class="filter-tabs">
      <button data-pane="loc">Loc.</button>
      <button data-pane="time">Time</button>
      <button data-pane="sys">Sys.</button>
      <button data-pane="etype">Event Type</button>
      <button data-pane="sort">Sort</button>
    </div>

    <div id="filter-panes">

    <div class="filter-pane" data-pane="loc" style="display:none;">
      <h4>Location</h4>
      <div class="filter-list">
        <label><input type="checkbox" value="STA1" data-filter="locations"> STA1</label>
        <label><input type="checkbox" value="STA2" data-filter="locations"> STA2</label>
        <label><input type="checkbox" value="TUN1" data-filter="locations"> TUN1</label>
        <label><input type="checkbox" value="NBT" data-filter="locations"> NBT</label>
      </div>
    </div>

    <div class="filter-pane" data-pane="time" style="display:none;">
      <h4>Time Range</h4>
      <div style="display:flex; flex-direction:column; gap:6px;">
        <label>
          From: <input type="datetime-local" id="timeFilterFrom">
        </label>
        <label>
          To: <input type="datetime-local" id="timeFilterTo">
        </label>
      </div>
    </div>


    <div class="filter-pane" data-pane="sys">
      <h4>System</h4>
      <div class="filter-list">
        <label><input type="checkbox" value="TRA" data-filter="systems"> TRA</label>
        <label><input type="checkbox" value="VENT" data-filter="systems"> VENT</label>
        <label><input type="checkbox" value="FIRE" data-filter="systems"> FIRE</label>
      </div>
    </div>

    <div class="filter-pane" data-pane="etype" style="display:none;">
      <h4>Event Type</h4>
      <div class="filter-list" id="etypeFilterList">
        <!-- checkboxes will be generated dynamically -->
      </div>
    </div>


    <div class="filter-pane" data-pane="sort" style="display:none;">
      <h4>Sort Order</h4>
      <div class="sort-list">
        <label>
          1st:
          <select id="sort1">
            <option value="">-- None --</option>
            <option value="ts">Time</option>
            <option value="loc">Location</option>
            <option value="sys">System</option>
            <option value="label">Label</option>
            <option value="desc">Description</option>
            <option value="state">State</option>
            <option value="type">Type</option>
          </select>
          <select id="sortDir1">
            <option value="desc">‚Üì</option>
            <option value="asc">‚Üë</option>
          </select>
        </label>
        <label>
          2nd:
          <select id="sort2">
            <option value="">-- None --</option>
            <option value="ts">Time</option>
            <option value="loc">Location</option>
            <option value="sys">System</option>
            <option value="label">Label</option>
            <option value="desc">Description</option>
            <option value="state">State</option>
            <option value="type">Type</option>
          </select>
          <select id="sortDir2">
            <option value="asc">‚Üë</option>
            <option value="desc">‚Üì</option>
          </select>
        </label>
        <label>
          3rd:
          <select id="sort3">
            <option value="">-- None --</option>
            <option value="ts">Time</option>
            <option value="loc">Location</option>
            <option value="sys">System</option>
            <option value="label">Label</option>
            <option value="desc">Description</option>
            <option value="state">State</option>
            <option value="type">Type</option>
          </select>
          <select id="sortDir3">
            <option value="asc">‚Üë</option>
            <option value="desc">‚Üì</option>
          </select>
        </label>
      </div>
      <p style="font-size:11px;color:#555;margin-top:4px;">
        Select at least one column. Sorting is applied in order of priority.
      </p>
    </div>


    
      </div>

      <div class="filter-actions">
        <button onclick="SCADA.UI.Events.applyFilters()">Apply</button>
        <button onclick="SCADA.UI.Events.resetFilters()">Reset</button>
      </div>

      <div id="eventCount" style="margin-top:4px; font-size:12px; color:#333; text-align:right;"></div>
      <div id="refreshPaused" style="margin-top:2px; font-size:12px; color:red; text-align:right; display:none;"> üî¥ Auto-refresh paused (time filter active)
</div>

    </div>
    
</div>

<style>
  #eventList {
    font-family: Arial, sans-serif;
    background: #ffffff;
    color: #000000;
    padding: 12px;
    height: 100%;
    box-sizing: border-box;
    user-select: none;   /* üëà prevent text selection */
  }

  #eventList table {
    width: 100%;
    border-collapse: collapse;
    table-layout: fixed; 
  }

  #eventList th, 
  #eventList td {
    padding: 6px 10px;
    border: 1px solid #7b7b7b;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  #eventList th {
    background: #c9c9c9;
    cursor: default;     /* üëà force normal arrow cursor */
  }
  #eventList tr:hover {
    background-color: #f0f0f0;  /* light grey highlight */
  }
  #eventList th:nth-child(1), 
  #eventList td:nth-child(1) { width: 200px; } /* Time */
  #eventList th:nth-child(2), 
  #eventList td:nth-child(2) { width: 50px; }  /* Loc */
  #eventList th:nth-child(3), 
  #eventList td:nth-child(3) { width: 50px; }  /* Sys */
  #eventList th:nth-child(4), 
  #eventList td:nth-child(4) { width: 70px; } /* Label */
  #eventList th:nth-child(5), 
  #eventList td:nth-child(5) { width: auto; }  /* Description = flexible */
  #eventList th:nth-child(6), 
  #eventList td:nth-child(6) { width: 120px; } /* State */
  #eventList th:nth-child(7), 
  #eventList td:nth-child(7) { width: 60px; }  /* Type */

  #eventPage {
    display: flex;
    height: 100%;
  }

  #eventListContainer {
    flex: 1;
    overflow: auto;
  }

  #eventFilter {
    width: 280px;
    background: #f4f4f4;
    border-left: 1px solid #ccc;
    display: flex;
    flex-direction: column;
    padding: 6px;
  }

  .filter-tabs {
    display: flex;
    margin-bottom: 6px;
  }

  .filter-tabs button {
    flex: 1;
    padding: 4px;
    margin-right: 2px;
    border: 1px solid #aaa;
    background: #e5e5e5;
    cursor: pointer;
  }
  .filter-tabs button.active {
    background: #fff;
    font-weight: bold;
  }

  .filter-pane {
    margin-top: 8px;
  }

  .filter-section {
    flex: none;
    margin-bottom: 10px;
    border: 1px solid #ccc;
    background: #fff;
    padding: 4px;
  }

  .filter-section h4 {
    margin: 0 0 4px 0;
    font-size: 12px;
    background: #ddd;
    padding: 2px;
  }

  .filter-list {
    max-height: 100px;
    overflow-y: auto;
    font-size: 12px;
  }

  .filter-actions {
    margin-top: auto;
    display: flex;
    justify-content: space-between;
  }
  .filter-actions button {
    flex: 1;
    margin: 2px;
  }

  .filter-list {
  display: grid;
  grid-template-columns: repeat(2, 1fr); /* 2 columns */
  gap: 4px 8px;
  max-height: 100px;
  overflow-y: auto;
  font-size: 12px;
}
.sort-list {
  display: flex;
  flex-direction: column;  /* stack items vertically */
  gap: 6px;                /* space between rows */
}

.sort-list label {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 13px;
}
.sort-list select {
  flex: 1;
  margin-left: 8px;
}



</style>

<script>

function updateEventFilterMarker() {
  const hasFilter =
    currentFilters.systems.length > 0 ||
    currentFilters.locations.length > 0 ||
    currentFilters.eventTypes.length > 0 ||
    currentFilters.time.from ||
    currentFilters.time.to;

  // üß≠ Use global helper in index.html to handle marker visibility
  window.parent?.SCADA?.UI?.updateFilterMarker("event", hasFilter);
}

  // === Persistent filter storage ===
  function loadSavedFilters() {
    try {
      const saved = localStorage.getItem("SCADA_EventFilters");
      return saved ? JSON.parse(saved) : null;
    } catch {
      return null;
    }
  }

  // === Restore visual state from saved filters ===
  function restoreFilterUI() {
    const panel = document.getElementById("eventPage");
    if (!panel) return;

    // --- 1. Restore system / location / event type checkboxes ---
    const checkboxes = panel.querySelectorAll('input[type="checkbox"][data-filter]');
    checkboxes.forEach(cb => {
      const type = cb.dataset.filter;
      const val = cb.value;
      cb.checked = currentFilters[type]?.includes(val);
    });

    // --- 2. Restore sort dropdowns ---
    const sortKey = currentFilters.sort?.[0]?.key || "ts";
    const sortDir = currentFilters.sort?.[0]?.dir || "desc";
    const sortKeySel = panel.querySelector('#sort1');
    const sortDirSel = panel.querySelector('#sortDir1');
    if (sortKeySel) sortKeySel.value = sortKey;
    if (sortDirSel) sortDirSel.value = sortDir;

    // --- 3. Restore time filters ---
    const fromInput = panel.querySelector('#timeFilterFrom');
    const toInput = panel.querySelector('#timeFilterTo');
    if (fromInput) fromInput.value = currentFilters.time?.from || "";
    if (toInput) toInput.value = currentFilters.time?.to || "";
  }

  function saveFilters() {
    try {
      localStorage.setItem("SCADA_EventFilters", JSON.stringify(currentFilters));
    } catch (e) {
      console.warn("‚ö†Ô∏è Could not save filters:", e);
    }
  }

  // --- Ensure connection to parent namespace (Phase 6 iframe mode) ---
  if (window.parent && window.parent.SCADA) {
    window.SCADA = window.parent.SCADA;
    console.log("‚úÖ Linked SCADA namespace from parent (iframe mode)");
  } else {
    window.SCADA = window.SCADA || { Core:{}, UI:{}, Symbols:{}, State:{} };
    console.warn("‚ö†Ô∏è Running standalone (no parent SCADA found)");
  }

  // === Phase 5: SCADA namespace bootstrap ===
  window.SCADA = window.SCADA || { Core:{}, Symbols:{}, UI:{}, State:{} };
  SCADA.UI = SCADA.UI || {};
  SCADA.UI.Events = SCADA.UI.Events || {};

  // --- Load and normalise saved filters ---
  window.currentFilters = loadSavedFilters() || {
    systems: [],
    locations: [],
    eventTypes: [],
    activePane: "loc",
    time: { from: null, to: null },
    sort: [{ key: "ts", dir: "desc" }]
  };
 
  function populateEventTypeFilters(events) {
    const listDiv = document.getElementById("etypeFilterList");
    if (!listDiv) return;

    // Save user selections before rebuilding
    const savedTicks = new Set(
      [...listDiv.querySelectorAll("input[type=checkbox]:checked")].map(cb => cb.value.trim().toUpperCase())
    );

    // Collect all unique types from events
    const types = [...new Set(events.map(ev => {const t = (ev.type || "").trim().toUpperCase();return t === "" ? "(NONE)" : t; }))].sort();


    // Clear previous checkboxes
    listDiv.innerHTML = "";

    // Build checkboxes fresh
    types.forEach(t => {
      const id = "etype_" + t;
      const label = document.createElement("label");
      label.innerHTML = `<input type="checkbox" value="${t}" id="${id}" data-filter="eventTypes"> ${t}`;
      const input = label.querySelector("input");

      // Restore user tick OR previously saved filter
      if (currentFilters.eventTypes.includes(t) || savedTicks.has(t)) {
        input.checked = true;
      }

      listDiv.appendChild(label);
    });
  }




// Persist filter state across page switches
const currentFilters = window.currentFilters;

function setActivePane(pane) {
  const panel = document.getElementById("eventPage");
  if (!panel) return;

  const buttons = panel.querySelectorAll('#eventFilter .filter-tabs button');
  const panes   = panel.querySelectorAll('#eventFilter .filter-pane');

  const valid = ["loc","time","sys","etype","sort"];
  if (!valid.includes(pane)) pane = "sys";

  buttons.forEach(b => b.classList.toggle('active', b.dataset.pane === pane));
  panes.forEach(p => p.style.display = (p.dataset.pane === pane) ? 'block' : 'none');

  console.log("Restored filter tab:", pane);
}

function initEventFilterTabs() {
  const panel = document.getElementById("eventPage");
  if (!panel) return;

  const buttons = panel.querySelectorAll('#eventFilter .filter-tabs button');
  buttons.forEach(btn => {
    // Remove old listener before re-binding
    btn.replaceWith(btn.cloneNode(true));
  });

  const freshButtons = panel.querySelectorAll('#eventFilter .filter-tabs button');
  freshButtons.forEach(btn => {
    btn.onclick = () => {
      currentFilters.activePane = btn.dataset.pane;
      setActivePane(currentFilters.activePane);
    };
  });

  setActivePane(currentFilters.activePane);
}

  function applyEventFilters() {
    const panel = document.getElementById("eventPage");
    const s1 = panel.querySelector('#sort1').value;
    const d1 = panel.querySelector('#sortDir1').value;
    const s2 = panel.querySelector('#sort2').value;
    const d2 = panel.querySelector('#sortDir2').value;
    const s3 = panel.querySelector('#sort3').value;
    const d3 = panel.querySelector('#sortDir3').value;

    currentFilters.sort = [];
    if (s1) currentFilters.sort.push({ key: s1, dir: d1 });
    if (s2) currentFilters.sort.push({ key: s2, dir: d2 });
    if (s3) currentFilters.sort.push({ key: s3, dir: d3 });


     

      currentFilters.systems = [...panel.querySelectorAll('.filter-pane[data-pane="sys"] input[type=checkbox]:checked')]
        .map(cb => cb.value.trim().toUpperCase());

      currentFilters.locations = [...panel.querySelectorAll('.filter-pane[data-pane="loc"] input[type=checkbox]:checked')]
        .map(cb => cb.value.trim().toUpperCase());

      const fromInput = panel.querySelector('#timeFilterFrom');
      const toInput   = panel.querySelector('#timeFilterTo');
      // preserve local time exactly as user entered it
      currentFilters.time.from = fromInput.value || null;
      currentFilters.time.to   = toInput.value   || null;



      currentFilters.eventTypes = [...panel.querySelectorAll('#etypeFilterList input[type=checkbox]:checked')]
        .map(cb => cb.value.trim().toUpperCase());

    loadEvents();
    syncFilterCheckboxes();  // keep UI in sync

    // ‚õî Stop refresh if time filter applied
    const pausedMsg = document.getElementById("refreshPaused");

    if (pausedMsg) {
      if (currentFilters.time.from || currentFilters.time.to) {
        pausedMsg.style.display = "block";
      } else {
        pausedMsg.style.display = "none";
      }
    }

  saveFilters(); 
  // Normalize back to Date objects in-memory (for next sync)
  if (typeof currentFilters.time.from === "string" && currentFilters.time.from)
    currentFilters.time.from = new Date(currentFilters.time.from);
  if (typeof currentFilters.time.to === "string" && currentFilters.time.to)
    currentFilters.time.to = new Date(currentFilters.time.to);
  updateEventFilterMarker();
  }

  function resetEventFilters() {
    currentFilters.systems = [];
    currentFilters.locations = [];
    currentFilters.eventTypes = [];
    currentFilters.time = { from: null, to: null };
    currentFilters.sort = [{ key: "ts", dir: "desc" }];   // default sort

    const panel = document.getElementById("eventPage");
    panel.querySelectorAll('#eventFilter input[type=checkbox]').forEach(cb => cb.checked = false);
    panel.querySelector('#timeFilterFrom').value = "";
    panel.querySelector('#timeFilterTo').value = "";
    panel.querySelector('#sort1').value = "ts";
    panel.querySelector('#sortDir1').value = "desc";
    panel.querySelector('#sort2').value = "";
    panel.querySelector('#sortDir2').value = "asc";
    panel.querySelector('#sort3').value = "";
    panel.querySelector('#sortDir3').value = "asc";

    loadEvents();
  
    const pausedMsg = document.getElementById("refreshPaused");
    if (pausedMsg) pausedMsg.style.display = "none";   // hide indicator after reset
    saveFilters(); 
    updateEventFilterMarker();
  }

 // --- Event load iwth iframe ---
async function openEventList() {
  stopAllRefreshTimers();

  try {
    const frame = document.getElementById("mimicFrame");
    if (!frame) throw new Error("No mimicFrame iframe found");

    // ‚úÖ Load inside iframe
    frame.src = "event.html";

    // ‚úÖ Update title
    const titleEl = document.getElementById("mimicTitle");
    if (titleEl) titleEl.textContent = "Event List";

    recordMimic("eventList", openEventList);
  } catch (err) {
    console.error("Event list load error:", err);
  }
}

// === Utility: select the latest 500 events by timestamp ===
function selectLatest500(arr) {
  if (!Array.isArray(arr)) return [];
  // Support either 'ts' or 'time' fields
  const getTs = (e) => new Date(e.ts || e.time || 0).getTime();
  // sort all events newest‚Üíoldest, then take top 500
  return arr.slice().sort((a, b) => getTs(b) - getTs(a)).slice(0, 500);
}

// --- Phase 6 universal loader ---
async function loadEvents() {
  try {
    // 1Ô∏è‚É£ If time filter active, load full static dataset and skip live updates
    if (currentFilters.time.from || currentFilters.time.to) {
      const res = await fetch("events.json", { cache: "no-store" });
      const json = await res.json();
      renderEventTable(json); // show all events, no 500 limit
      console.log("‚è∏ Time filter active ‚Üí static full dataset loaded");
      return;
    }

    // 2Ô∏è‚É£ Otherwise use live cached data if available
    const cachedAll = window.parent?.SCADA?.Core?.PollManager?.latestData?.events;
    if (Array.isArray(cachedAll)) {
      console.log("Loaded", cachedAll.length, "events from global cache");
      renderEventTable(selectLatest500(cachedAll));
      return;
    }

    // 3Ô∏è‚É£ Fallback: full fetch + trim to 500
    const res = await fetch("events.json", { cache: "no-store" });
    const json = await res.json();
    renderEventTable(selectLatest500(json));
  } catch (err) {
    console.error("‚ö†Ô∏è loadEvents() error:", err);
  }
}



  function renderEventTable(events) {
    populateEventTypeFilters(events);
    const tbody = document.querySelector("#eventTable tbody");
    if (!tbody) return;

    const scrollPos = tbody.parentElement.scrollTop;
    tbody.innerHTML = "";

    let filtered = [...events];

    // ‚úÖ Apply filters here (case-insensitive)
    if (currentFilters.systems.length > 0) {
      filtered = filtered.filter(ev =>
        currentFilters.systems.includes((ev.sys || "").trim().toUpperCase())
      );
    }

    if (currentFilters.locations.length > 0) {
      filtered = filtered.filter(ev =>
        currentFilters.locations.includes((ev.loc || "").trim().toUpperCase())
      );
    }

    // Time filter ‚Äî supports "YYYY-MM-DDTHH:mm" strings
    if (currentFilters.time.from || currentFilters.time.to) {
      const from = currentFilters.time.from ? new Date(currentFilters.time.from) : null;
      const to   = currentFilters.time.to   ? new Date(currentFilters.time.to)   : null;

      filtered = filtered.filter(ev => {
        const ts = new Date(ev.ts || ev.time);
        if (isNaN(ts)) return false;
        if (from && ts < from) return false;
        if (to && ts > to) return false;
        return true;
      });
    }



    // Event type filter
    if (currentFilters.eventTypes.length > 0) {
      filtered = filtered.filter(ev => {
        let t = (ev.type || "").trim().toUpperCase();
        if (t === "") t = "(NONE)";
        return currentFilters.eventTypes.includes(t);
      });
    }


    // ‚úÖ Always sort newest to oldest by default (unless overridden)
    if (currentFilters.sort.length === 0) {
      currentFilters.sort = [{ key: "ts", dir: "desc" }];
    }

    filtered.sort((a, b) => {
      for (let { key, dir } of currentFilters.sort) {
        let av = a[key] || "";
        let bv = b[key] || "";

        if (key === "ts") {
          av = new Date(av);
          bv = new Date(bv);
          if (isNaN(av) || isNaN(bv)) continue;
        } else {
          av = av.toString().toUpperCase();
          bv = bv.toString().toUpperCase();
        }

        if (av < bv) return dir === "asc" ? -1 : 1;
        if (av > bv) return dir === "asc" ? 1 : -1;
      }
      return 0;
    });




    filtered
      .forEach(ev => {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${ev.ts || ""}</td>
          <td>${ev.loc || ""}</td>
          <td>${ev.sys || ""}</td>
          <td>${ev.label || ""}</td>
          <td>${ev.desc || ""}</td>
          <td>${ev.state || ""}</td>
          <td>${(ev.type && ev.type.trim()) ? ev.type : ""}</td>
          `;

        // Make row navigable by double-click
        tr.style.cursor = "pointer";
        tr.addEventListener("dblclick", (e) => {
          e.stopPropagation();

          const key = `${(ev.loc || "").toUpperCase()}-${(ev.sys || "").toUpperCase()}-${(ev.label || "").toUpperCase()}`;
          if (window.parent) window.parent.__highlightEquipKey = key;
          else window.__highlightEquipKey = key;

          const mapped = (SCADA?.Core?.MimicMap && SCADA.Core.MimicMap[key])
            ? SCADA.Core.MimicMap[key]
            : null;

          if (mapped && typeof SCADA?.UI?.selectMimicFile === "function") {
            console.log("Event dblclick mapped", key, "->", mapped);
            SCADA.UI.selectMimicFile(mapped);
          } else if (typeof SCADA?.UI?.selectSystem === "function") {
            console.log("Event dblclick fallback", key);
            SCADA.State.currentLocation = (ev.loc || "").toUpperCase();
            SCADA.UI.selectSystem((ev.sys || "").toUpperCase());
          }

          });
 
        tbody.appendChild(tr);
      });
    
     tbody.parentElement.scrollTop = scrollPos;
    console.log("Active filter:", currentFilters.systems);
    
    // Update event count in filter panel
    const countEl = document.getElementById("eventCount");
    if (countEl) {
      countEl.textContent = `${filtered.length} event${filtered.length !== 1 ? "s" : ""} shown`;
    }

    console.log("Server returned:", events.length, "After filtering:", filtered.length);

  }

  async function clearEvents() {
    await fetch("/api/events/clear", { method:"POST" });
    loadEvents();
  }


// --- Register under SCADA.UI.Events ---
SCADA.UI.Events.loadEvents = loadEvents;
SCADA.UI.Events.applyFilters = applyEventFilters;
SCADA.UI.Events.resetFilters = resetEventFilters;
SCADA.UI.Events.syncCheckboxes = syncFilterCheckboxes;
SCADA.UI.Events.initTabs = initEventFilterTabs;

  function syncFilterCheckboxes() {
    const panel = document.getElementById("eventPage");
    if (!panel) return;

    const sysCbs = panel.querySelectorAll('.filter-pane[data-pane="sys"] input[type=checkbox]');
    sysCbs.forEach(cb => {
      cb.checked = currentFilters.systems.includes(cb.value.trim().toUpperCase());
    });

    const locCbs = panel.querySelectorAll('.filter-pane[data-pane="loc"] input[type=checkbox]');
    locCbs.forEach(cb => {
      cb.checked = currentFilters.locations.includes(cb.value.trim().toUpperCase());
    });

    const fromInput = panel.querySelector('#timeFilterFrom');
    const toInput   = panel.querySelector('#timeFilterTo');

    // Safely handle either ISO strings or Date objects
    if (fromInput) {
      if (currentFilters.time.from) {
        const f = currentFilters.time.from;
        const val = typeof f === "string" ? f.slice(0, 16) : f.toISOString().slice(0, 16);
        fromInput.value = val;
      } else {
        fromInput.value = "";
      }
    }

    if (toInput) {
      if (currentFilters.time.to) {
        const t = currentFilters.time.to;
        const val = typeof t === "string" ? t.slice(0, 16) : t.toISOString().slice(0, 16);
        toInput.value = val;
      } else {
        toInput.value = "";
      }
    }

    const etypeCbs = panel.querySelectorAll('#etypeFilterList input[type=checkbox]');
      etypeCbs.forEach(cb => {
        cb.checked = currentFilters.eventTypes.includes(cb.value.trim().toUpperCase());
      });

    const sortSelects = ["sort1","sort2","sort3"].forEach((id, i) => {
      const el = panel.querySelector('#' + id);
      const dirEl = panel.querySelector('#sortDir' + (i+1));
      if (el) el.value = currentFilters.sort[i]?.key || "";
      if (dirEl) dirEl.value = currentFilters.sort[i]?.dir || "asc";
    });



  }

  
// ==========================================================
// Phase 6 ‚Äî Reliable real-time EventList via PollManager
// ==========================================================
// --- Auto-save Event filters when page unloads ---
window.addEventListener("beforeunload", () => saveFilters());

document.addEventListener("DOMContentLoaded", () => {
  function trySubscribe() {
    try {
      const PM = window.parent?.SCADA?.Core?.PollManager;
      if (!PM) {
        console.warn("‚ö†Ô∏è PollManager not ready ‚Äî retrying...");
        setTimeout(trySubscribe, 1000);
        return;
      }

      // --- Load saved filters first ---
      const saved = loadSavedFilters();
      if (saved) window.currentFilters = saved;

      // --- Restore UI and re-sync checkboxes ---
      restoreFilterUI();
      syncFilterCheckboxes();
      initEventFilterTabs();

      // --- Apply marker & then load events using restored filters ---
      updateEventFilterMarker();
      loadEvents();

      
      // --- Restore "auto-refresh paused" indicator if time filter is active ---
      const pausedMsg = document.getElementById("refreshPaused");
      if (pausedMsg) {
        if (currentFilters.time.from || currentFilters.time.to) {
          pausedMsg.style.display = "block";
        } else {
          pausedMsg.style.display = "none";
        }
      }

    // === Phase 8.2.1 correction: stable PollManager subscription ===
    if (typeof PM.subscribe === "function") {
      // Clear any previous local subscription
      if (window.__eventUnsub) {
        window.__eventUnsub();
        window.__eventUnsub = null;
      }

      // Register fresh subscription
      window.__eventUnsub = PM.subscribe(({ events }) => {
        if (!Array.isArray(events)) return;

        // ‚è∏ Skip real-time update if time filter is active
        if (currentFilters.time.from || currentFilters.time.to) return;

        renderEventTable(selectLatest500(events));
      });

      console.log("‚úÖ EventList subscribed to PollManager live updates (WebSocket mode)");
    } else {
      console.warn("‚ö†Ô∏è PollManager.subscribe() missing ‚Äî fallback to manual fetch");
      loadEvents();
      setInterval(loadEvents, 2000);
    }

    } catch (err) {
      console.error("‚ö†Ô∏è Error while subscribing EventList:", err);
      setTimeout(trySubscribe, 1000);
    }
  }

  // initial attempt
  trySubscribe();
});



</script>

<script>
  console.log('[REG-TEST] Page: Event List loaded');

  // ‚úÖ Phase 8.2.1 fix ‚Äî guard against missing Event Bus in iframe
  if (SCADA?.Core?.Bus?.emit) {
    SCADA.Core.Bus.emit('page:title', { page: 'Events' });
  } else {
    console.log('‚ÑπÔ∏è Bus not available (iframe mode) ‚Üí skipping title emit');
  }

</script>


